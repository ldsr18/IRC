====================
FICHIER: ./README.md
====================



====================
FICHIER: ./srcs/main.cpp
====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/06 08:43:54 by jdecarro          #+#    #+#             */
/*   Updated: 2026/02/06 08:43:54 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "server.hpp"

int main(int argc, char **argv)
{
	if (argc != 3)
	{
		std::cerr << "Usage: ./ircserv <port> <password>" << std::endl;
		return (1);
	}

	int port = std::atoi(argv[1]);
	std::string password = argv[2];
	
	Server serv(port, password);
	serv.run();
}


====================
FICHIER: ./srcs/server.cpp
====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/06 09:19:17 by jdecarro          #+#    #+#             */
/*   Updated: 2026/02/06 09:19:17 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "server.hpp"
#include "client.hpp"

Server::Server(int port, const std::string& password) : _port(port), _serverFd(-1), _password(password)
{
	setupSocket();
}

Server::~Server()
{
	close(_serverFd);
}

void Server::setupSocket()
{
	_serverFd = socket(AF_INET, SOCK_STREAM, 0);
	if (_serverFd < 0)
		throw std::runtime_error("Socket failed!");

	int opt = 1;
	setsockopt(_serverFd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	sockaddr_in addr;
	std::memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(_port);
	
	if (bind(_serverFd, (sockaddr*)&addr, sizeof(addr)) < 0)
		throw std::runtime_error("bind failed");
	if (listen(_serverFd, SOMAXCONN) < 0)
		throw std::runtime_error("listen failed");
		
	// non-bloquant (OBLIGATOIRE pour ft_irc)
	fcntl(_serverFd, F_SETFL, O_NONBLOCK);
	
	pollfd pfd;
	pfd.fd = _serverFd;
	pfd.events = POLLIN;
	_fds.push_back(pfd);
	
	std::cout << "Server listening on port " << _port << std::endl;
}

void Server::run()
{
	while (true)
	{
		int ret = poll(&_fds[0], _fds.size(), -1);
		if (ret < 0)
			throw std::runtime_error("poll failed");

		for (size_t i = 0; i < _fds.size(); i++)
		{
			if (_fds[i].revents & POLLIN)
			{
				if (_fds[i].fd == _serverFd)
					acceptClient();
				else
				{
					if (!receiveFromClient(_fds[i].fd))
						i--;
				}
			}
		}
	}
}

void Server::acceptClient()
{
	sockaddr_in clientAddr;
	socklen_t len = sizeof(clientAddr);

	int clientFd = accept(_serverFd, (sockaddr*)&clientAddr, &len);
	if (clientFd < 0)
		return;

	fcntl(clientFd, F_SETFL, O_NONBLOCK);

	pollfd pfd;
	pfd.fd = clientFd;
	pfd.events = POLLIN;
	_fds.push_back(pfd);

	_clients.insert(std::make_pair(clientFd, Client(clientFd)));

	std::cout << "Client connected (fd = " << clientFd << " )" << std::endl;
}

bool Server::receiveFromClient(int clientFd)
{
	char buffer[512];
	std::memset(buffer, 0, sizeof(buffer));

	ssize_t bytes = recv(clientFd, buffer, sizeof(buffer) - 1, 0);

	if (bytes <= 0)
	{
		std::cout << "Client disconnected (fd = " << clientFd << ")\n";
		close(clientFd);
		removeFd(clientFd);
		_clients.erase(clientFd);
		return (false);
	}

	std::map<int, Client>::iterator it = _clients.find(clientFd);
	if (it == _clients.end())
		return (true); //ne devrait jamais arriver
	Client& client = it->second;
	// Ajout au buffer du client
	client.getBuffer().append(buffer, bytes);

	std::string& buf = client.getBuffer();
	size_t pos;

	// Extraction des messages complets (\r\n)
	while ((pos = buf.find("\r\n")) != std::string::npos)
	{
		std::string message = buf.substr(0, pos);
		buf.erase(0, pos + 2);

		//debug, à supprimer a la fin !!!!!!!!!!
		std::cout << "Complete message from fd " << clientFd << ": [" << message << "]" << std::endl;
		
		Command cmd = parseCommand(message);
		if (!cmd.name.empty())
			handleCommand(client, cmd);
	}
	return (true);
}

void Server::removeFd(int fd)
{
	for (size_t i = 0; i < _fds.size(); i++)
	{
		if (_fds[i].fd == fd)
		{
			_fds.erase(_fds.begin() + i);
			return;
		}
	}
}

Command Server::parseCommand(const std::string& line)
{
	Command cmd;

	size_t pos = line.find(" :");
	std::string commandPart;
	std::string messagePart;

	if (pos != std::string::npos)
	{
		commandPart = line.substr(0, pos);
		messagePart = line.substr(pos + 2);
	}
	else
		commandPart = line;

	std::istringstream iss(commandPart);
	std::string word;

	if (iss >> word)
		cmd.name = word;
	while (iss >> word)
		cmd.params.push_back(word);

	if (!messagePart.empty())
		cmd.params.push_back(messagePart);

	return (cmd);
}

void Server::handleCommand(Client& client, const Command& cmd)
{
	if (cmd.name == "PASS")
		handlePass(client, cmd);
	else if (cmd.name == "NICK")
		handleNick(client, cmd);
	else if (cmd.name == "USER")
		handleUser(client, cmd);
	else if (cmd.name == "JOIN")
		handleJoin(client, cmd);
	else if (cmd.name == "INVITE")
		handleInvite(client, cmd);
	else
		sendError(client, "421", cmd.name + " :Unknown command");

	if (client.isRegistered() && !client.hasWelcomed())
	{
		sendWelcome(client);
		client.setWelcomed(true);
	}
}

Channel* Server::findChannelByName(const std::string& name) {

	std::map<std::string, Channel>::iterator it = _channels.find(name);
	if(it == _channels.end())
			return NULL;
	return &it->second;
}

Client* Server::findClientByNick(const std::string& nick) {

	std::map<int, Client>::iterator it;
	for(it = _clients.begin(); it != _clients.end(); it++) {
		if(it->second.getNick() == nick)
			return &it->second;
	}
	return NULL;
}

// INVITE <nick> <#channel>
void Server::handleInvite(Client& client, const Command& cmd) {
	if(!client.isRegistered()) {
		sendError(client, "451", " :You have not registered");
		return;
	}
	else if(cmd.params.size() < 2) {
		sendError(client, "461", "INVITE :Not enough parameters");
		return;
	}
	Client* target = findClientByNick(cmd.params[0]);
	if(!target) {
		sendError(client, "401", cmd.params[0] + " :No such nick");
		return;
	}
	Channel* channel = findChannelByName(cmd.params[1]);
	if(!channel) {
		sendError(client, "403", cmd.params[1] + " :No such channel");
		return;
	}
	if(!channel->hasMember(client.getFd())) {
		sendError(client, "442", cmd.params[0] + cmd.params[1] + " You're not on that channel");
		return;
	} 
	if(channel->hasMember(target->getFd())) {
		sendError(client, "443", cmd.params[0] + cmd.params[1] + " :Already member of that channel");
		return;
	}
	if(channel->isInvited(target->getFd())) {
		sendError(client, "443", cmd.params[0] + " " + cmd.params[1] + " :Already invited on that channel");
		return;
	}
	if(!channel->isModerator(client.getFd()))  {
		sendError(client, "482", " :You're not channel operator”");
		return;
	}

	channel->invite(target->getFd());
	sendInvit(client, *target, *channel);
	sendReply(client, *target, *channel, "341");

}

void Server::handlePass(Client& client, const Command& cmd)
{
	if (client.passAccepted())
	{
		sendError(client, "462", " :You may not reregister");
		return;
	}
	if (cmd.params.size() < 1)
	{
		sendError(client, "461", "PASS :Not enough parameters");
		return;
	}
	if (cmd.params[0] != _password)
	{
		sendError(client, "464", " :Password incorrect");
		return;
	}
	client.setPassAccepted(true);
}

void Server::handleNick(Client& client, const Command& cmd)
{
	if (!client.passAccepted())
	{
		sendError(client, "451", " :You have not registered");
		return;
	}
	if (cmd.params.size() < 1)
	{
		sendError(client, "431", " *:No nickname given");
		return;
	}
	std::string nickname = cmd.params[0];
	if (nicknameExists(nickname))
	{
		sendError(client, "433", "* " + nickname + " :Nickname is already use");
		return;
	}
	client.setNick(nickname);
}

void Server::handleUser(Client& client, const Command& cmd)
{
	if (!client.passAccepted())
	{
		sendError(client, "451", " :You have not registered");
		return;
	}
	if (cmd.params.size() < 4)
	{
		sendError(client, "461", "User :Not enough parameters");
		return;
	}
	client.setUser(cmd.params[0]);
}

void Server::handleJoin(Client& client, const Command& cmd)
{
	 if (!client.isRegistered())
	{
		sendError(client, "451", " :You have not registered");
		return;
	}
	if (cmd.params.size() < 1)
	{
		sendError(client, "461", "JOIN :Not enough parameters");
		return;
	}
	std::string channelName = cmd.params[0];
	if (channelName[0] != '#')
	{
		sendError(client, "476", channelName + " :Bad Channel Mask");
		return;
	}
	if (_channels.find(channelName) == _channels.end())
		_channels.insert(std::make_pair(channelName, Channel(channelName)));
	Channel& channel = _channels[channelName];
	
	channel.addMember(client.getFd());
	if (channel.memberCount() == 1)
		channel.addModerator(client.getFd());
	
	std::string msg = ":" + client.getNick() + "!" + client.getUser() + "@localhost JOIN " + channelName + "\r\n";
	broadcastToChannel(channel, msg, -1);
	sendNames(client, channel);
}
// PRIVMSG

bool Server::nicknameExists(const std::string& nick)
{
	for (std::map<int, Client>::iterator it = _clients.begin(); it != _clients.end(); ++it)
	{
		if (it->second.getNick() == nick)
			return (true);
	}
	return (false);
}

void Server::sendReply(Client& client, Client& target, Channel& channel, std::string const& code) {
	std::string output 		= ":ircserv " + code + " " + client.getNick() + " " 
							+ target.getNick() + " " + channel.name() + "\r\n";
	send(client.getFd(), output.c_str(), output.size(), 0);
}

void Server::sendInvit(Client& client, Client& target, Channel& channel)
{
	std::string output = 	":" + client.getNick() + "!" + client.getUser()
							+ "@localhost INVITE "+ target.getNick() + " " 
							+ channel.name() + "\r\n";
	send(target.getFd(), output.c_str(), output.size(), 0);
}

void Server::sendError(Client& client, const std::string& code, const std::string& message)
{
	std::string output = ":ircserv " + code + " * " + message + "\r\n";
	send(client.getFd(), output.c_str(), output.size(), 0);
}

void Server::sendWelcome(Client& client)
{
	std::string output = ":ircserv 001 " + client.getNick() + " :Welcome to our ircserv " + client.getNick() + "\r\n";
	send(client.getFd(), output.c_str(), output.size(), 0);
}

void Server::sendNames(Client& client, Channel& channel)
{
	std::string list;
	const std::set<int>& members = channel.members();

	for (std::set<int>::const_iterator it = members.begin(); it != members.end(); ++it)
	{
		Client& member = _clients[*it];
		if (channel.isModerator(*it))
			list += "@";
		list += member.getNick() + " ";
	}
	
	if (!list.empty())
		list.erase(list.size() - 1);
	
	std::string reply353 = ":ircserv 353 " + client.getNick() + " = " + channel.name() + " :" + list + "\r\n";
	send(client.getFd(), reply353.c_str(), reply353.size(), 0);
	std::string reply366 = ":ircserv 366 " + client.getNick() + " " + channel.name() + " :End of /NAMES list.\r\n";
	send(client.getFd(), reply366.c_str(), reply366.size(), 0);
}

void Server::broadcastToChannel(Channel& channel, const std::string& msg, int exceptFd)
{
    const std::set<int>& mem = channel.members();
    for (std::set<int>::const_iterator it = mem.begin(); it != mem.end(); ++it)
    {
        int fd = *it;
        if (fd == exceptFd) continue;
        send(fd, msg.c_str(), msg.size(), 0);
    }
}






====================
FICHIER: ./srcs/client.cpp
====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   client.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/09 11:00:02 by jdecarro          #+#    #+#             */
/*   Updated: 2026/02/09 11:00:02 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "client.hpp"

Client::Client() : _fd(-1), _passAccepted(false), _hasNick(false), _hasUser(false), _welcomed(false)
{
}

Client::Client(int fd) : _fd(fd), _passAccepted(false), _hasNick(false), _hasUser(false), _welcomed(false)
{
}

bool Client::passAccepted() const
{
	return (_passAccepted);
}

bool Client::hasNick() const
{
	return (_hasNick);
}

bool Client::hasUser() const
{
	return (_hasUser);
}

bool Client::isRegistered() const
{
	return (_passAccepted && _hasNick && _hasUser);
}

bool Client::hasWelcomed() const
{
	return (_welcomed);
}

int Client::getFd() const
{
	return (_fd);
}

std::string& Client::getBuffer()
{
	return (_buffer);
}

const std::string& Client::getNick() const
{
	return (_nickname);
}

const std::string& Client::getUser() const
{
	return (_username);
}

void Client::setWelcomed(bool value)
{
	_welcomed = value;
}

void Client::setPassAccepted(bool value)
{
	_passAccepted = value;
}

void Client::setNick(const std::string& nick)
{
	_nickname = nick;
	_hasNick = true;
}

void Client::setUser(const std::string& user)
{
	_username = user;
	_hasUser = true;
}



====================
FICHIER: ./srcs/channel.cpp
====================
#include "channel.hpp"

Channel::Channel()
: _name(""),
  _limit(0),
  _inviteOnly(false),
  _topicRestricted(false),
  _hasKey(false),
  _hasLimit(false) {}

Channel::Channel(std::string name)
: _name(name),
  _limit(0),
  _inviteOnly(false),
  _topicRestricted(false),
  _hasKey(false),
  _hasLimit(false) {}

Channel::~Channel() {}

bool	Channel::hasMember(int fd) const
{ 
	return _members.find(fd) != _members.end();
}

bool	Channel::addMember(int fd)
{ 
	return _members.insert(fd).second; // _members.insert(fd) retourne paire(iterator, bool) bool sur si il a ete bien insert ou pas
}

bool	Channel::removeMember(int fd)
{ 
	size_t erasd = _members.erase(fd);
	_moderators.erase(fd);
	_invited.erase(fd);
	return erasd != 0;
}


bool	Channel::isModerator(int fd) const
{ 
	return _moderators.find(fd) != _moderators.end();
}

bool	Channel::addModerator(int fd)
{ 
	if(!hasMember(fd))
		return false;
	return _moderators.insert(fd).second;
}

bool	Channel::removeModerator(int fd)
{ 
	return _moderators.erase(fd) != 0;
}

//	Topic
std::string const& Channel::topic() const
{ 
	return _topic;
}

void	Channel::setTopic(const std::string& t)
{
	_topic = t;
}

// Invites (+i)
bool	Channel::isInviteOnly() const
{ 
	return _inviteOnly;
}

void	Channel::setInviteOnly(bool io)
{ 
	_inviteOnly = io;
}

bool	Channel::isInvited(int fd) const
{ 
	return _invited.find(fd) != _invited.end();
}

void	Channel::invite(int fd)
{ 
	_invited.insert(fd);
}

void	Channel::uninvite(int fd)
{ 
	_invited.erase(fd);
}

//	Key (+k)
bool	Channel::hasKey() const
{ 
	return _hasKey;
}

bool	Channel::checkKey(const std::string& key) const
{ 
	if(!_hasKey)
		return true;
	return _key == key;
}

void	Channel::setKey(const std::string& key)
{ 
	_key = key;
	_hasKey = true;
}

void	Channel::clearKey()
{ 
	_key.clear();
	_hasKey = false;
}

//	Limit (+l)
bool	Channel::hasLimit() const
{ 
	return _hasLimit;
}

size_t	Channel::limit() const
{ 
	return _limit;
}

void	Channel::setLimit(size_t n)
{ 
	_limit = n;
	_hasLimit = true;
}

void	Channel::clearLimit()
{ 
	_limit = 0;
	_hasLimit = false;
}

bool	Channel::isFull() const
{ 
	if(! _hasLimit)
		return false;
	return _members.size() >= _limit;
}

std::string const& Channel::name() const
{ 
	return _name;
}

std::set<int> const& Channel::members() const
{ 
	return _members;
}


size_t Channel::memberCount() const
{ 
	return _members.size();
}

bool Channel::empty() const
{ 
	return _members.empty();
}



====================
FICHIER: ./incs/client.hpp
====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   client.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/09 10:55:27 by jdecarro          #+#    #+#             */
/*   Updated: 2026/02/09 10:55:27 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CLIENT_HPP
#define CLIENT_HPP

#include <iostream>
#include <string>

class Client
{
	private:
			int _fd;
			std::string _buffer;

			bool _passAccepted;
			bool _hasNick;
			bool _hasUser;
			bool _welcomed;
			
			std::string _nickname;
			std::string _username;

	public:
			Client();
			Client(int fd);

			//getter d'état
			bool passAccepted() const;
			bool hasNick() const;
			bool hasUser() const;
			bool isRegistered() const;
			bool hasWelcomed() const;

			//getter
			int getFd() const;
			std::string& getBuffer();
			const std::string& getNick() const;
			const std::string& getUser() const;
			void setWelcomed(bool value);

			//setter
			void setPassAccepted(bool value);
			void setNick(const std::string& nick);
			void setUser(const std::string& user);
};

#endif


====================
FICHIER: ./incs/channel.hpp
====================
#ifndef CHANNEL_HPP
#define CHANNEL_HPP

#include <set>
#include <string>
#include <cstddef>

class Channel
{
	private :

		std::string		_name;
		std::set<int>	_members;
		std::set<int>	_moderators;
		std::set<int>	_invited; 		// invitations (fd)
		std::string		_topic;
		std::string		_key;			// +k
		size_t			_limit; 		// +l

		bool _inviteOnly; 		// +i
		bool _topicRestricted; 	// +t
		bool _hasKey;
		bool _hasLimit;

	public:

		Channel();
		Channel(std::string name);
		~Channel();


		bool	hasMember(int fd) const;
		bool	addMember(int fd);
		bool	removeMember(int fd);

		bool	isModerator(int fd) const;
		bool	addModerator(int fd);
		bool	removeModerator(int fd);

		//	Topic
		std::string const& topic() const;
		void	setTopic(const std::string&);

		// Invites (+i)
		bool	isInviteOnly() const;
		void	setInviteOnly(bool);
		bool	isInvited(int fd) const;
		void	invite(int fd);
		void	uninvite(int fd);

		//	Key (+k)
		bool	hasKey() const;
		bool	checkKey(const std::string& key) const;
		void	setKey(const std::string& key);
		void	clearKey();

		//	Limit (+l)
		bool	hasLimit() const;
		size_t	limit() const;
		void	setLimit(size_t n);
		void	clearLimit();
		bool	isFull() const;

		std::string const& name() const;
		std::set<int> const& members() const;

		size_t memberCount() const;
		bool empty() const;
};

#endif


====================
FICHIER: ./incs/command.hpp
====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/11 15:23:50 by jdecarro          #+#    #+#             */
/*   Updated: 2026/02/11 15:25:32 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef COMMAND_HPP
#define COMMAND_HPP

#include <string>
#include <vector>

class Command
{
	public:
			std::string name;
			std::vector<std::string> params;

};

#endif


====================
FICHIER: ./incs/server.hpp
====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/06 08:45:12 by jdecarro          #+#    #+#             */
/*   Updated: 2026/02/06 08:45:12 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVER_HPP
#define SERVER_HPP

#include "client.hpp"
#include "command.hpp"
#include "channel.hpp"

#include <iostream>
#include <cstring>
#include <vector>
#include <cstdlib>
#include <map>
#include <sstream>

#include <unistd.h> //close
#include <fcntl.h>
#include <sys/socket.h> //socket, bind, listen...
#include <netinet/in.h> //sockaddr_in
#include <arpa/inet.h> //htons
#include <poll.h> //poll, pollfd


class Server
{
	private:
			int _port;
			int _serverFd; //fd du serveur = le socket qui écoute
			std::string _password;
			std::map<std::string, Channel> _channels;

			std::vector<struct pollfd> _fds;
			std::map<int, Client> _clients;

			//réseau
			void setupSocket(); //crée et prépare lee serveur
			void acceptClient();
			bool receiveFromClient(int clientFd);
			void removeFd(int fd);

			//parsing command
			Command parseCommand(const std::string& line);
			void handleCommand(Client& client, const Command& cmd);

			//gestion authentification
			void handlePass(Client& client, const Command& cmd);
			void handleNick(Client& client, const Command& cmd);
			void handleUser(Client& client, const Command& cmd);
			void handleJoin(Client& client, const Command& cmd);
			bool nicknameExists(const std::string& nick);

			//channel
			Channel* findChannelByName(const std::string& nick);
			Client* findClientByNick(const std::string& nick);
			void handleInvite(Client& client, const Command& cmd);

			//réponses
			void sendError(Client& client, const std::string& code, const std::string& message);
			void sendWelcome(Client& client);
			void sendNames(Client& client, Channel& channel);
			void sendInvit(Client& client, Client& target, Channel& channel);
			void sendReply(Client& client, Client& target, Channel& channel, std::string const& code);
			void broadcastToChannel(Channel& channel, const std::string& msg, int exceptFd);

	public:
			Server(int port, const std::string& password);
			~Server();

			void run();
};

#endif


====================
FICHIER: ./Makefile
====================
NAME = ircserv

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98 -Iincs

SRCS =	srcs/main.cpp \
		srcs/server.cpp \
		srcs/client.cpp \
		srcs/channel.cpp

OBJS = $(SRCS:.cpp=.o)

all: $(NAME)

$(NAME): $(OBJS)
	$(CXX) $(CXXFLAGS) $(OBJS) -o $(NAME)

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re



